\chapter{Introduction}
\label{ch:introduction}

\section{Motivation and Goal of the Thesis}

Cancer is a widespread and often lethal disease\cite{10.1001/jamaoncol.2021.6987} where body cells mutate in a way that increases their cell division speed as well as their lifetime while also evading natural cancer prevention mechanisms. There are many possible treatment methods like surgery, chemotherapy, or radiation therapy, but their effectiveness often depends on the exact type of tumor. The complexity of choosing the correct therapy is increased since the tumor cells may mutate again and form metastases in different parts of the body. These developments however can be anticipated by analysing the genome of a tumor and finding new, emerging subclones that may require different treatments even before they are dominant.

Bulk sequencing of tumor cells and analysing the found mutations is already widely used, but often misses out on smaller, upcoming variants since they are averaged out in the mass of cells. Therefore, research has been done to utilise single cell sequencing. With this technique, the exact genome of individual cells can be identified and compared against other cells. However, it also comes with high error rates and parts of a cell's genome are often lost during the process. It is therefore impossible to compute an exact phylogenetic tree with this data. Instead, one has to resort to find the most plausible one.

One algorithm to compute the most likely phylogeny from a set of erroneous cell genomes is \ac{SCITE}\cite{tree2016}. The original authors provided a functional, but rather unoptimized implementation of their algorithm. While I know of an optimized but unpublished implementation of \ac{SCITE} for CPUs, there has not been an efficient implementation for \acp{FPGA} to my knowledge. \acp{FPGA} are computer chips that contain a lattice of logic, computation, and memory units that are connected via programmable connections. They basically emulate a complete computer chip and have already been used extensively for chip prototyping and verification. In recent years they have also become interesting as computation accelerators for \ac{HPC} clusters due to their low power consumption compared to their performance. However, developing efficient \ac{FPGA} designs is tedious since compiling them often takes multiple hours and naive designs are often multiple orders of magnitudes worse than optimized ones. \todo[inline]{Add notes about usage}

However, with the introduction of Intel's oneAPI, it has become possible to develop \ac{FPGA} designs using C++ templates, a form of polymorphism that is very suitable for \ac{FPGA} designs: Datatypes and functions are implemented with placeholders that can be replaced with actual types and constants during compilation. When set up correctly, one can therefore implement different solutions to the same problem, integrate the different solutions in the build system, compile the different versions in parallel and evaluate the resulting designs side by side. I have already employed this method while developing StencilStream, a Generic Stencil Simulation Library for \acp{FPGA}, and it significantly improved my productivity.

My goal for this thesis is therefore to develop an efficient implementation of SCITE for \acp{FPGA} using oneAPI and the aforementioned development pattern. This implementation should be at least as fast as the original author's implementation, but possibly as fast as the optimized CPU version mentioned previously or even faster. With this, I want to showcase the increased productivity of \ac{FPGA} development with oneAPI, that even an undergraduate student can develop efficient FPGA designs in the limited amount of time of a Bachelor's Thesis.

\section{Problem Formulation}

The input is a function $D: C \times G \rightarrow \{0, 1, ?\}$, where $C$ is the set of sampled cells and $G$ is a set of genome positions. If for a cell $c \in C$ and a genome position $g \in G$ we have $D(c, g) = 1$, the genome position $g$ has been observed as mutated in cell $c$, and if we have $D(c, g) = 0$, the genome position $g$ has been observed in it's common form. There is also a third option $D(c, g) = ?$, which means that the genome position has not been found at all and no statement could be made whether it is mutated or not. As the existance of the $?$ option may indicate, this function is noisy and may contain errors. It is assumed that errors occur independently from each other and if we let $E: C \times G \rightarrow \{0, 1\}$ be the true state of the cells, we have
\begin{align*}
    \mathbb{P}(D(c, g) = 0 \mid E(c, g) = 0) &= 1 - \alpha & \mathbb{P}(D(c, g) = 1 \mid E(c, g) = 0) &= \alpha \\
    \mathbb{P}(D(c, g) = 0 \mid E(c, g) = 1) &= \beta & \mathbb{P}(D(c, g) = 1 \mid E(c, g) = 1) &= 1 - \beta
\end{align*}
for some error rates $\alpha, \beta \in (0, 1)$. Error modeling for $D(c, g) = ?$ is not given by the authors. Missing data is always ignored in probability calculations.

The goal now is to find a mutation tree, a cell attachment and error rates with a high likelihood of being correct. A mutation tree is a rooted tree $T = (G \cup \{r\}, E, r)$ where $r$ is the root of the tree and the other nodes are genome positions. It expresses that the mutation of $g \in G$ has occured after all it's ancestors, prior to it's successors and independently from all unrelated genome positions. A cell attachment is a simple function $\sigma: C \rightarrow G$ and expresses that a cell $c \in C$ has the mutation status just after $\sigma(c)$ was mutated. Therefore, a cell $c$ has mutations at all genome positions that are ancestors of $\sigma(c)$, but at no other positions. This model is sensible since the authors of \ac{SCITE} make the ``infinite sites'' assumption, which states that a genome position mutates exactly once in the complete history of the tumor and does not mutate back.

With the mutation tree $T$ and a cell attachment $\sigma$, we can now build a function $e_{(T, \sigma)}: C \times G \rightarrow \{0, 1\}$ that expresses the made statements of the cell's true mutation status. Formally, we set
\begin{align*}
    e_{(T, \sigma)}(c, g) &:= \begin{cases}
        1 & g \in \mathrm{Anc}_T(\sigma(c)) \\
        0 & \text{else} \\
    \end{cases}
\end{align*}
where $\mathrm{Anc}_T(g)$ is the set of ancestors of a genome position $g \in G$ with respect to $T$. Therefore, the likelihood of a tree and cell attachment given the observed data $d$ and the error rates $\alpha$ and $\beta$ is
\begin{align*}
    \prod_{c \in C}\prod_{g \in G} \mathbb{P}_{(\alpha, \beta)}(D(c, g) = d(c, g) \mid E(c, g) = e_{(T, \sigma)}(c, g))
\end{align*}
Since pairs of $(c, g) \in C \times G$ with $d(c, g) = ?$ are ignored, the probabilities in the product above are always set to 1. As stated before, the goal is now to find the tuple $(T, \sigma, \alpha, \beta)$ with the highest likelihood.

\section{Algorithm introduction}

\ac{SCITE} is a \ac{MCMC} algorithm. A Monte Carlo algorithm runs a random experiment that produces possible solutions to a problem and evaluates how well the generated solutions solve the problem. This operation of generating and evaluating a solution is then repeated multiple times and the result is the best solution the algorithm has encountered. In theory, it would suffice if the experiment had a probability greater than zero to produce a good solution, but in order to improve the solution quality and to reduce the required repetitions, one would use an experiment that produces the best solutions with a higher probability than worse solutions and that can be repeated quickly. As the name implies, \ac{MCMC} algorithms simulate a Markov Chain to produce solutions. The advantage of using Markov Chains is that the next sample may depend on the previous one. The algorithm may therefore introduce small changes to the solution. This is obviously faster than generating a new solution from scratch and if the current sample is already a good solution, the change may preserve some of its quality. However, a designer of a \ac{MCMC} algorithm has to make sure that the chain actually converges on the desired distribution.

\section{Previous Work}

\section{Work Schedule}