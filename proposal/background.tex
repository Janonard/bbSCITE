\section{Background}

In order to properly explain the solved problem, it is best to introduce it formally. This formulation is derived from the original author's formulation \cite{tree2016}, but enhanced for understandability. The input can be viewed as a function $D: C \times G \rightarrow \{0, 1, ?\}$, where $C$ is the set of sampled cells and $G$ is a set of genome positions. If for a cell $c \in C$ and a genome position $g \in G$ we have $D(c, g) = 1$, the genome position $g$ has been observed as mutated in cell $c$, and if we have $D(c, g) = 0$, the genome position $g$ has been observed in it's common form. There is also a third option $D(c, g) = ?$, which means that the genome position has not been found at all and no statement could be made whether it is mutated or not. As the existance of the $?$ option may indicate, this function is noisy and may contain errors. It is assumed that errors occur independently from each other and if we let $S: C \times G \rightarrow \{0, 1\}$ be the true state of the cells, we have
\begin{align*}
    \mathbb{P}(D(c, g) = 0 \mid S(c, g) = 0) &= 1 - \alpha & \mathbb{P}(D(c, g) = 1 \mid S(c, g) = 0) &= \alpha \\
    \mathbb{P}(D(c, g) = 0 \mid S(c, g) = 1) &= \beta & \mathbb{P}(D(c, g) = 1 \mid S(c, g) = 1) &= 1 - \beta
\end{align*}
for some error rates $\alpha, \beta \in (0, 1)$. Error modeling for $D(c, g) = ?$ is not given by the authors; Missing data is always ignored in probability calculations.

The goal now is to find a mutation tree, a cell attachment and error rates with the maximum likelihood of being correct. A mutation tree is a rooted tree $T = (G \cup \{r\}, E, r)$ where $r$ is the root of the tree and the other nodes are genome positions. It expresses that the mutation of $g \in G$ has occured after all it's tree ancestors, prior to it's tree successors and independently from all unrelated genome positions in the tree. A cell attachment is a simple function $\sigma: C \rightarrow G$ and expresses that a cell $c \in C$ has the mutation status just after $\sigma(c)$ was mutated. Therefore, a cell $c$ has mutations at all genome positions that are ancestors of $\sigma(c)$, but at no other positions. This model is sensible since the authors of \ac{SCITE} make the ``infinite sites'' assumption, which states that a genome position mutates exactly once in the complete history of the tumor and does not mutate back.

With the mutation tree $T$ and a cell attachment $\sigma$, we can now build a function $s_{(T, \sigma)}: C \times G \rightarrow \{0, 1\}$ that expresses the made statements of the cell's true mutation status. Formally, we set
\begin{align*}
    s_{(T, \sigma)}(c, g) &:= \begin{cases}
        1 & g \in \mathrm{Anc}_T(\sigma(c)) \\
        0 & \text{else} \\
    \end{cases}
\end{align*}
where $\mathrm{Anc}_T(g)$ is the set of ancestors of a genome position $g \in G$ with respect to $T$. Therefore, the likelihood of a tree and cell attachment given the observed data $d$ and the error rates $\alpha$ and $\beta$ is
\begin{align*}
    \prod_{c \in C}\prod_{g \in G} \mathbb{P}_{(\alpha, \beta)}(D(c, g) = d(c, g) \mid S(c, g) = s_{(T, \sigma)}(c, g))
\end{align*}
Since pairs of $(c, g) \in C \times G$ with $d(c, g) = ?$ are ignored, their probabilities in the product above are always set to 1. We can now formally say that given a set of cells $C$, a set of genome positions $G$, and the observed data $D: C \times G \rightarrow \{0, 1, ?\}$, an algorithm has to find a tuple $(T, \sigma, \alpha, \beta)$ with the maxmimum likelihood.

\ac{SCITE} is a \ac{MCMC} algorithm. A Monte Carlo algorithm runs a random experiment that produces a possible solution to a problem and evaluates how well the generated solution solves the problem. This operation of generating and evaluating a solution is then repeated multiple times and the result is the best solution the algorithm has encountered. In theory, it would suffice if the experiment had a probability greater than zero to produce a good solution, but in order to improve the solution quality and to reduce the required repetitions, one would use an experiment that produces the best solutions with a higher probability than worse solutions and that can be repeated quickly. As the name implies, \ac{MCMC} algorithms simulate a Markov Chain to produce solutions. The advantage of using Markov Chains is that the next sample may depend on the previous one and the algorithm therefore only needs to introduce small changes to the solution. This is often faster than generating a new solution from scratch and if the current sample is already a good solution, the change may preserve some of its quality. However, a designer of a \ac{MCMC} algorithm has to make sure that the chain actually converges on the desired distribution.

\ac{SCITE} actually modifies and approximates the problem: Instead of producing a maxmimum likelihood 4-tuple of a tree $T$, cell attachment $\sigma$, and the error rates $\alpha$ and $\beta$, it only produces a maximum likelihood tuple of a tree $T$ and the error rate $\beta$, summed over all possible cell attachments and with a fixed $\alpha$. In one iteration, it proposes a change either to $T$ or to $\beta$. Changes to $\beta$ are just the addition of a normally distributed summand, but there are multiple possible changes to $T$: It may either be ``Prune and Reattach'' where a subtree is removed and attached to a node in the remaining tree, ``Label Swap'' where two nodes are swapped in the tree, or ``Subtree Swap'' where two complete subtrees are swapped. After the change has been proposed, it's likelihood is computed and it is stored if it's the most likely solution yet. The proposed change however is not always accepted as the next state of the Markov Chain. Instead, rejection sampling is used to make solutions with a higher likelihood more probable to be drawn.

After publishing \ac{SCITE}, Kuipers et al. surveyed the validity of the infinite sites assumption and published a modified version of \ac{SCITE} called \ac{infSCITE} \cite{kuipers2017single}. \ac{infSCITE} extends the likelihood model of \ac{SCITE} by allowing a single genome position to mutate twice and introduced the possibility that two cells may have been sequenced together and appear as a single cell in the data. While the authors were able to use this version of the algorithm to show that the infinite sites assumption may not always hold true, we question its productive use. From our understanding, a model without the infinite sites assumption should allow an arbitrary amount of recurrent mutations and we therefore do not consider implementing \ac{infSCITE}'s likelihood model, although it may be technically feasible.