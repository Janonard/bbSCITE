\section{Goals and Planned Work}

With the algorithm introduced, we can formulate our goals:
\begin{itemize}
    \item Implementing \ac{SCITE} for Intel Stratix 10 GX 2800 \acp{FPGA}, using Intel oneAPI and DPC++.
    \begin{itemize}
        \item Maximal Markov Chain steps per second (Throughput).
        \item At least as much throughput as the original reference implementation.
        \item Results of comparable likelihood to the original reference implementation.
        \item (Optional) More throughput than Ernst et al. \cite{ernst2020Performance}.
    \end{itemize}
    \item Developing benchmarking and validation tools for our and reference implementations.
    \begin{itemize}
        \item Including a performance model for our implementation.
        \item Developing statistical hypothesis tests for the performance model and output quality.
    \end{itemize}
\end{itemize}

The goal of performing better than Ernst et al. is optional because of two reasons: On one hand, \ac{FPGA} design development is a delicate process and we might encounter big problems that may not be solvable in time. On the other hand however, we do not have access to Ernst's implementation or its performance figures yet. We are trying to gain access to it, but if we are unable to do so, we can not check whether we have achieved this goal. However, we intend to create models for our design's performance. This means that even if we can not meet our performance goals, we can still point out where the bottlenecks are and how the work may be continued. Lastly, we will also need tools to verify the likelihood of the results. Producing the exact same results as the references may impose unnecessary restrictions to the design and therefore, we need the freedom to produce different solutions of comparable likelihood.

The first task will be an initial implementation of the algorithm with Intel oneAPI. This implementation may be naive and therefore possibly inefficient, but it should be functional and correct. Next, we will need to set up the verification and benchmarking system to establish the baseline of the initial FPGA implementation and the reference implementation. Once the foundations are established, we can begin to optimize. There is not much sense in planning this task since it heavily depends on the bottlenecks at hand, but it will probably result in repeated iterations of profiling, identification of bottlenecks, research in existing solutions, implementating existing or original ideas and analysing the changes. We will write-up the findings from all analysis stages, which will aid use in the last phase: Writing the thesis and proofreading it. There, we will describe which performance we could achieve, which bottlenecks we have encountered and how we have resolved them. More precisely, we plan to use the following structure for the thesis:

\begin{itemize}
    \item Introduction
    \begin{itemize}
        \item Motivation
        \item Background
        \item Related Work
    \end{itemize}
    \item Implementation
    \begin{itemize}
        \item Notable Bottlenecks and Solutions
        \item Verification \& Benchmarking Framework
    \end{itemize}
    \item Results
    \begin{itemize}
        \item Result likelihood
        \item Performance
    \end{itemize}
    \item Conclusion
\end{itemize}

\begin{figure}
    % Modified from https://git.cs.uni-paderborn.de/syssec/templates/exposee
    \begin{ganttchart}
        [today=0, %"TODAY" vertical line
        x unit=0.5cm, %extend sheets to 1cm
        ]{1}{18}
        \gantttitle[title label node/.append style={below left=7pt and -3pt}]{WEEKS:\quad1}{1}
        \gantttitlelist{2,...,18}{1} \\
        \ganttgroup{Initial Implementation}{1}{4} \\
        \ganttgroup{Verification \& Benchmarking}{2}{6} \\
        \ganttgroup{Optimization}{5}{12} \\
        \ganttgroup{Writing \& Proofreading}{13}{18}
    \end{ganttchart}
    \centering
    \caption{Worst-Case work schedule}
    \label{fig:worstschedule}
\end{figure}

According to the regulations, the workload of the thesis is supposed to contain nine weeks of full time labor, which is equivalent to 18 weeks of half time labor. The deadline for handing the thesis in is five months, which is approximately equivalent to 21 to 22 weeks and leaves a buffer of three to four weeks. We assume that the initial implementation will take approximately four weeks, as we will need to rewrite the complete application due to its heavy use of dynamic memory in datastructures and the kernel code, as well as its imperative structure. Benchmarking will be rather easy with our experience in profiling oneAPI FPGA designs, but since we have no experience in statistical verification, we can not actually make a good prediction for the required time. For writing the thesis, other students have quoted approximately four to six weeks of half-time work for thesis writing and proofreading, which leaves approximately nine to thirteen weeks between the initial implementation and writing the thesis for optimization. The resulting worst-case work schedule is visualized in figure \ref{fig:worstschedule}.
