\section{Conclusion and Future Work}

In this work, we have introduced \ac{ffSCITE}, an \ac{FPGA} design and implementation of the \ac{SCITE} algorithm that outperforms the original CPU reference by up to 80$\times$. % that is optimized for high-level \ac{FPGA} designs. 
%We have introduced \ac{ffSCITE}, an implementation of the \ac{SCITE} algorithm that is optimized for high-level \ac{FPGA} designs. 
For inputs matching the design parameters, a performance model illustrates the good occupancy of the FPGA design.
%The resulting design is utilized well and performs the same workloads up to 80 times as fast as the original reference implementation for CPUs. 
We have also approximated the maximum performance that an optimized CPU implementation can achieve for one of the core loops of \ac{ffSCITE}. Even here, the FPGA performance is en-par with current high-performance CPUs at much lower power consumption, while outperforming CPUs of the same manufacturing technology by an order of magnitude.

We see several directions for future work. A main limitation of the current design are the maximal input and mutation matrix sizes fixed at compile-time. A blocking approach could open up the design for arbitrarily large inputs, possibly at the cost of decreased performance.
On the other hand, since the presented designs still leave a signification fraction of FPGA resources unused, there could be headroom for further performance improvements, for example via replications of the worker kernel.

%We can see multiple directions for future work: First of all, we are certain that even more throughput could be achieved by replicating the entire design. Even the 96-bit \ac{ffSCITE} instance only utilizes 29\% of all \acp{LUT} and has 46\% to spare for one or maybe two replications to double or triple the end-to-end throughput. Additional resource-saving optimizations on lower levels could increase this speedup even further. Another fundamental limitation of the design is the fixed input and mutation matrix sizes. Further developments could open up the design for arbitrarily large inputs, possibly at the cost of decreased performance.
