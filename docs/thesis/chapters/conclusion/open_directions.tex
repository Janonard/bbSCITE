\section{Open directions}
\label{sec:open_directions}

Time is always a limiting factor during a bachelor's thesis. We therefore tried to limit the scope of the thesis as much as necessary to assure that we meet our goals. This however means that there are some optional or alternative features of the original \ac{SCITE} implementation we were unable to implement. Additionally, it is almost always possible to further optimize an application. In this section, we therefore discuss both the removed features and possibilities for future optimizations that we saw during this thesis.

\paragraph{Feature: Co-optimal trees}
The most practical feature of the reference implementation that we could not implement is exporting co-optimal trees. For most inputs, there are multiple trees with the same, maximum likelihood. A user will probably want to know about all of these trees in order to interpret the results correctly. However, there is a high probability that these trees are visited multiple times, and an implementation of the \ac{SCITE} algorithm therefore needs to check for duplicates. This is not a trivial task, especially on \acp{FPGA}. We therefore initially decided to only store one maximum likelihood tree at first and then extend our design once the rest is satisfactory. However, we did not reach this point and it therefore remains an open direction.

\paragraph{Feature: $\beta$ search}
There is one feature that we actually implemented, but that we did not mention in this thesis: The reference implementation also supports searching for the most likely false-negative probability $\beta$. However, it is not properly documented in the paper and it occasionally produces values $>1$. We therefore decided not to evaluate it in our quality test, but since the reference implementation of the $\beta$ search also did not affect our design's performance in a meaningful way, we also decided to leave it in.

\paragraph{Feature: Additional scoring methods}
The first truly optional features we chose not to implement are additional scoring methods for mutation trees. The first one is the so-called ``sum score'' which was published as a part of the reference implementation of \ac{SCITE}. It does not compute the likelihood of a true mutation matrix, but the a posteriori probability of the true mutation matrix given the input mutation matrix. In the language of Bayesian probability theory, it computes $\mathbb{P}(E|D)$ instead of $\mathbb{P}(D|E)$ where $D$ is the noisy mutation matrix and $E$ is the true mutation matrix to score. The main technical difference is that it additionally potentiates the scores of the individual cell-node pairs, executes a sum-reduction on all possible attachment points of a cell, and then takes the logarithm of the sum for the global sum reduction. We assume that an implementation of this a posteriori score would require even more hardware or have less throughput than the likelihood score since its computation is already the most-unrolled and most resource-consuming part of the design.

The second scoring method is \ac{infSCITE}, which was published by Kuipers et al. \cite{kuipers2017single} as a successor to \ac{SCITE} to test the infinite sites assumption. We initially set ourselves the optional goal to at least evaluate whether an adaption of \ac{ffSCITE} to the \ac{infSCITE} scoring scheme is possible, but we were not able to do this in time for this thesis.

\paragraph{Feature: Homo- and heterozygous mutations}
Another unimplemented feature is the support for homozygous and heterozygous mutations. As far as we understand it, homozygous mutations are mutations where both chromosomes carry the mutation, and heterozygous mutations are mutations where only one chromosome carries it. This was probably implemented to support the data provided by Hou et al. \cite{hou2012single}, which reports these two types of mutations. However, it was not mentioned in the paper, and since we tried to keep our implementation simple, we chose not to implement it.

\paragraph{Feature: Continous outputs}
The reference implementation continuously emits information about the current chain and step index as well as the current maximum score. Additionally, it can also write samples from the chains into separate files. These features are very useful to users as they allow them to make predictions of the required number of chains and chain steps as well as the runtime. \ac{ffSCITE} however does not emit this information since it only writes back its results after the entire execution is complete. Implementing these features does not require much effort, but it was not necessary for our goals and has therefore not been done yet.

\paragraph{Optimization: Customized random draws}
The current scheme leaves much room for optimization. First of all, there may be \acp{URNG} that work better on \acp{FPGA} and have a shorter critical path than Minstd. We think that it is probably impossible to remove the data dependency completely since the output is supposed to appear random, but there may be room for improvement. Secondly, our current approach is very wasteful with random bits: For example, we use Minstd's output, which has up to $m = 2^{32} - 1$ possible values, to sample one of 64 nodes and then draw another number to sample one of the other 63 nodes. Since we have upper bounds for all set sizes we want to sample from, it might be possible to sample multiple move parameters from one \ac{URNG} draw and save resources and execution time. However, we assume that this will require much more research outside our current expertise and time to implement and verify.

\paragraph{Optimization: Resolve compiler issues with bigger inputs}
\ac{ffSCITE} currently supports inputs with up to 64 cells and 63 genes. Compiling the design with more cells and genes however leads to internal compiler errors that we were not able to resolve. If \ac{ffSCITE} is supposed to be used by practitioners, then this issue needs to be resolved since real inputs are likely to be bigger than 64x63.

\paragraph{Optimization: Replicate the design}
The current design uses only one replication of the pipeline. If the resource usage can be reduced, it may be possible to fit the same design twice on one Intel Stratix 10 \ac{FPGA} so that the outputs of the first replication are fed into the second replication and both work in parallel. Additionally, we have the option at the Noctua 2 supercomputer to expand the design to multiple interconnected \acp{FPGA} which can then work in parallel too. Ernst et al. \cite{ernst2020Performance} have shown that the \ac{SCITE} algorithm can easily be parallelized on independent cores or devices, so this should also be possible to accomplish with \acp{FPGA} too.

\paragraph{Exploration: Energy Efficiency}
\acp{FPGA} are known by some for their energy efficiency \cite{betkaoui2010comparing} since developers have direct control over data movement and data subsequently needs to be moved less inside the \ac{FPGA} and between the \ac{FPGA} and external memory. This may be true especially in the case of \ac{SCITE} since the reference implementation always writes the resulting state back to a relatively big buffer which may or may not reside in a cache, while \ac{ffSCITE} never copies intermediate states to the global memory in the first place. We, therefore, assume that \ac{ffSCITE} is more energy efficient than the CPU-based versions by Jahn et al. \cite{tree2016} and Ernst et al. \cite{ernst2020Performance}. However, we would need to verify this and it is therefore an open direction.