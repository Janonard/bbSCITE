\section{Tree encoding and operations}

Our first and most impactful contribution is an improvement to the used mutation tree encoding and the operations on this code. The original \ac{SCITE} implementation \cite{tree2016} uses a parent vector as the canonical data structure to encode a mutation tree:

\begin{definition}[Parent vector, \cite{tree2016}]
    \label{def:parent_vector}
    Let $T = (V, E, r)$ be a mutation tree. The corresponding parent vector is defined as the sequence $(p_v)_{v \in V} \subseteq V$ with
    \begin{align*}
        p_v &:= \begin{cases}
            p_T(v) & v \neq r \\
            r & v = r 
        \end{cases}
    \end{align*}
\end{definition}

Using this encoding has the obvious advantage that most of the tree moves are simple: The updates in the ``prune and reattach'' and ``swap subtrees'' moves of \textsc{ChainStep} (Algorithm \ref{alg:scite-step}) are mere constant operations. The update operations in the ``swap nodes'' move are more involved since every edge needs to be visited and checked, but it is still in linear runtime. However, sampling moves and computing the likelihood function requires many connectivity queries: Both the ``prune and reattach'' and the ``swap subtrees'' moves may need to sample a target that is not a descendant of the moved node, and the induced mutation matrix (Definition \ref{def:induced_mutmatrix}) is defined by node connectivity. Therefore, a separate data structure is used to answer these queries quickly:

\begin{definition}[Ancestor matrix, \cite{tree2016}]
    \label{def:ancestor_matrix}
    Let $T = (V, E, r)$ be a mutation tree. The corresponding ancestor matrix is defined as the matrix $A \in \{0,1\}^{|V| \times |V|}$ with
    \begin{align*}
        A_{v,w} &:= \begin{cases}
            1 & v \leadsto_T w \\
            0 & \text{else}
        \end{cases}
    \end{align*}
    for all $v, w \in V$.
\end{definition}

\begin{algorithm}[p]
    \begin{algorithmic}[1]
        \Function{AncestorMatrix}{$(p_v)_{v \in V} \subseteq V, r \in V$} \Comment $r$ is the root of the tree.
            \State $n \leftarrow |V|$
            \State $a \leftarrow 0 \in \{0,1\}^{n \times n}$
            \ForAll{$w \in V$}
                \State $v \leftarrow w$
                \While{$v \neq r$}
                    \State $a_{v, w} \leftarrow 1$
                    \State $v \leftarrow p_v$
                \EndWhile
                \State $a_{r, w} \leftarrow r$
            \EndFor
            \State \Return $a$
        \EndFunction
    \end{algorithmic}
    \caption{Algorithm to construct an ancestor matrix (Definition \ref{def:ancestor_matrix}) from a parent vector (Definition \ref{def:parent_vector}), \cite{tree2016}}
    \label{alg:ancestor_matrix}
\end{algorithm}

It is obvious that connectivity queries can be executed in constant time using an ancestor matrix. Additionally, since we assume an upper bound for the number of nodes, we can use the flexibility of \acp{FPGA} to implement ancestor matrices as an array with $n$ $n$-bit words, where $n$ is the maximal number of nodes. To answer the query $i \leadsto_T j$, we only need to load the word with index $i$ and extract the bit with index $j$.

Jahn et al. \cite{tree2016} also give an algorithm that constructs an ancestor matrix from a parent vector; We have listed it as algorithm \ref{alg:ancestor_matrix}. Intuitively, it walks up from every node to the root and marks all nodes it encounters as ancestors. \ac{SCITE} uses this algorithm twice per chain step, once before sampling a move and once after the move was executed to compute the likelihood function. Hardware implementations of this algorithm are however inefficient since it is hard to predict how often the inner while-loop is executed. For example, it may be executed $|V|$ times for the leaf of a completely degenerated tree, but it may not be executed at all for the root $r$. Therefore, the outer for-loop needs to be executed serially, which severely limits the performance of the design. However, we were able to eliminate the need to construct ancestor matrices on the device. First of all, we were able to show with theorem \ref{theo:am_reverse} that it is possible to find a node's parent using an ancestor matrix. Ancestor matrices can therefore be used as the canonical data structure to encode mutation trees. More importantly, however, we were able to show with theorem \ref{theo:am_update} that every move of the \textsc{ChainStep} algorithm (Algorithm \ref{alg:scite-step}) can be executed on an ancestor matrix with linear time and space requirements. This leaves us with one linear, perfectly pipelinable loop to update the ancestor matrix for a move. Compared to the two quadratic, barely pipelinable loops to compute the ancestor matrix twice, this is certainly an improvement.

\subsection{Reversing the ancestor matrix construction}

\begin{theorem}
    \label{theo:am_reverse}
    Let $T=(V, E, r)$ be a mutation tree, $a \in \{0, 1\}^{|V| \times |V|}$ be the corresponding ancestor matrix, and $(v, w) \in V^2$ be a node pair. The algorithm \textsc{IsParent} (Algorithm \ref{alg:is_parent}) returns True iff $v = p_T(w)$ given the inputs $V$, $a$ and $(v,w)$.
\end{theorem}

The algorithm uses Lemma \ref{lem:am_reverse} to check whether the requested edge exists in the tree, with an additional shortcut for the root.

\begin{lemma}
    \label{lem:am_reverse}
    Let $T = (V, E)$ be a tree and $v, w \in V$. We have:
    \begin{align*}
        (v, w) \in E \Leftrightarrow (\forall x \in V \setminus \{w\}: x \leadsto_T v \Leftrightarrow x \leadsto_T w) \wedge (v \leadsto_T w)
    \end{align*}
\end{lemma}

\begin{proof}
    We first show $\Rightarrow$: We obviously have $v \leadsto_T w$. Let $x \in V \setminus \{v\}$. Then, we have:
    \begin{align*}
        x \leadsto_T w  &\Rightarrow \exists p = (x, \dots, w) \subseteq E \\
                        &\stackrel{(v, w) \in E}{\Rightarrow} (v, w) \in p \\
                        &\Rightarrow p' := p \setminus \{(v, w)\} = (x, \dots, v) \subseteq E \\
                        &\Rightarrow x \leadsto_T v \\
        x \leadsto_T v  &\Rightarrow \exists p = (x, \dots, v) \subseteq E \\
                        &\stackrel{(v, w) \in E}{\Rightarrow} p' := p \cup \{(v, w)\} = (x, \dots, v, w) \subseteq E \\
                        &\Rightarrow x \leadsto_T w
    \end{align*}
    Now, we show $\Leftarrow$: Let's assume for a contradiction that we have $(\forall x \in V \setminus \{w\}: x \leadsto_T v \Leftrightarrow x \leadsto_T w) \wedge (v \leadsto_T w)$ and $(v, w) \notin E$. We have:
    \begin{align*}
        v \leadsto_T w \wedge (v, w) \notin E &\Rightarrow \exists y \in V \setminus \{v, w\}: v \leadsto_T y \leadsto_T w \\
        y \leadsto_T w \wedge y \neq w &\Rightarrow y \leadsto_T v \\
        &\Rightarrow y \leadsto_T v \leadsto_T y
    \end{align*}
    This means that our tree has a circle, which is a contradiction. Therefore, such a $y$ can not exist and we have in fact $p = (v, \dots, w) = (v, w) \Rightarrow (v, w) \in E$.
\end{proof}

\begin{algorithm}[p]
    \begin{algorithmic}[1]
        \Function{IsParent}{$V$, $a \in \{0,1\}^{|V| \times |V|}$, $(v, w) \in V^2$}
            \If{$a_{v,w} = 0$}
                \State \Return False
            \EndIf
            \If{$v = w$}
                \State \Return $v = r$ \Comment Per convention, the root is the only node that is also its parent.
            \EndIf
            \ForAll{$x \in V \setminus \{w\}$}
                \If{$a_{x,w} \neq a_{x,v}$}
                    \State \Return False
                \EndIf
            \EndFor
            \State \Return True
        \EndFunction
    \end{algorithmic}
    \caption{Algorithm to query whether an edge exists in a tree, using an ancestor matrix}
    \label{alg:is_parent}
\end{algorithm}

\subsection{Ancestor matrix updates}

\begin{definition}[Tree moves, \cite{tree2016}]
    \label{def:tree_moves}
    Let $T = (V, E, r)$ be a mutation tree, $v, w \in V \setminus \{r\}$ with $v \neq w$, $t_1 \in V$ with $v \not\leadsto_T t_1$, and $t_2 \in V$ with $v \leadsto_T t_2$. We define four different moves:
    \begin{itemize}
        \item ``Swap nodes:'' $T' = (V, E', r)$ with $E' := \{(f(x), f(y)) : (x, y) \in E\}$ and
        \begin{align*}
            f: V \rightarrow V, x \mapsto \begin{cases}
                v & x = w \\
                w & x = v \\
                x & \text{else} \\
            \end{cases}
        \end{align*}
        \item ``Prune and Reattach:'' $T' = (V, E', r)$ with $E' := (E \setminus \{(p_T(v), v)\}) \cup \{(t_1, v)\}$.
        \item ``Swap unrelated subtrees:'' $T' = (V, E', r)$ with
        \begin{align*}
            E' := (E \setminus \{(p_T(v), v), (p_T(w), w)\}) \cup \{(p_T(w), v), (p_T(v), w)\}
        \end{align*}
        if we have $v \not\leadsto_T w$ and $w \not \leadsto_T v$.
        \item ``Swap related subtrees:'' $T' = (V, E', r)$ with 
        \begin{align*}
            E' := (E \setminus \{(p_T(v), v), (p_T(w), w)\}) \cup \{(p_T(w), v), (t_2, w)\}
        \end{align*}
        if we have $w \leadsto_T v$.
    \end{itemize}
\end{definition}

\begin{algorithm}[p]
    \begin{algorithmic}[1]
        \Function{AM::SwapNodes}{$V$, $a \in \{0,1\}^{|V| \times |V|}$, $v$, $w$}
            \State $a' \leftarrow 0 \in \{0,1\}^{|V| \times |V|}$
            \ForAll{$x \in V$}
                \If{$x = v$}
                    \State $a'[x] \leftarrow a[w]$
                \ElsIf{$x = w$}
                    \State $a'[x] \leftarrow a[v]$
                \Else
                    \State $a'[x] \leftarrow a[x]$
                \EndIf
                \State $a'[x][v], a'[x][w] \leftarrow a'[x][w], a'[x][v]$ \Comment Bit Swap
            \EndFor
            \State \Return $a'$
        \EndFunction
    \end{algorithmic}
    \caption{Algorithm to perform the ``swap nodes'' move on an ancestor matrix. All edges from and to $v$ are $w$ are swapped, assuming that we have $v \neq w$.}
    \label{alg:am_swap_nodes}
\end{algorithm}

\begin{theorem}[Correctness of the ``Swap nodes'' update]
    \label{theo:swap_nodes_correctness}
    Let $T = (V, E, r)$ be a mutation tree, $v, w \in V$ with $v \neq w$ and $a \in \{0,1\}^{|V| \times |V|}$ the corresponding ancestor matrix of $T$. The ancestor matrix returned by \textsc{AM::SwapNodes}$(V, a, v, w)$ (Algorithm \ref{alg:am_swap_nodes}) is the corresponding ancestor matrix of the tree $T'$ after the ``Swap nodes'' move (Definition \ref{def:tree_moves}).
\end{theorem}

\begin{proof}
    Let $a'$ be the return value of the mentioned function call. We need to show that $a'$ has the correct value for every node pair $x, y \in V$. To be precise, we need to show that $a'[x][y] = f(x) \leadsto_T f(y)$ for all $x, y \in V$ since we have $x \leadsto_{T'} y \Leftrightarrow f(x) \leadsto_T f(y)$ with Lemma \ref{lem:swap_nodes_property}. We distinguish several cases for the node pair:
    \begin{itemize}
        \item $x \notin \{v, w\} \wedge y \notin \{v, w\}$. In this case, the algorithm initially sets $a'[x]$ to $a[x]$ and the $y$-th bit is untouched by the bit swap, so we have $a'[x][y] = a[x][y] = a[f(x)][f(y)] = f(x) \leadsto_T f(y)$.
        
        \item $x \in \{v, w\} \wedge y \notin \{v, w\}$. We show the sub-case $x = v$ since $x = w$ is analogous. The algorithm initially sets $a'[x]$ to $a[w]$ and the $y$-th bit is untouched by the bit swap. Therefore, we have $a'[x][y] = a[w][y] = a[f(x)][f(y)] = f(x) \leadsto_T f(y)$.
        
        \item $x \notin \{v, w\} \wedge y \in \{v, w\}$. We show the sub-case $y = v$ since $y = w$ is analogous. The algorithm initially sets $a'[x]$ to $a[x]$ and swaps the $v$-th bit with the $w$-th bit. Therefore, we have $a'[x][y] = a[x][w] = a[f(x)][f(y)] = f(x) \leadsto_T f(y)$.
        
        \item $x \in \{v, w\} \wedge y \in \{v, w\} \wedge x = y$. We show the sub-case $x = y = v$ since $x = y = w$ is analogous. The algorithm initially sets $a'[x]$ to $a[w]$ and swaps the $v$-th bit with the $w$-th bit. Therefore, we have $a'[x][y] = a[w][w] = a[f(x)][f(y)] = f(x) \leadsto_T f(y)$.
        
        \item $x \in \{v, w\} \wedge y \in \{v, w\} \wedge x \neq y$. We show the sub-case $x = v$ since $x = w$ is analogous. We have $x = v \wedge x \neq y \Rightarrow y = w$. The algorithm initially sets $a'[x]$ to $a[w]$ and swaps the $v$-th bit and the $w$-th bit. Therefore, we have $a'[x][y] = a[w][v] = a[f(x)][f(y)] = f(x) \leadsto_T f(y)$.
    \end{itemize}
\end{proof}

\begin{lemma}
    \label{lem:swap_nodes_property}
    Let $T = (V, E, r)$ be a mutation tree, $v, w \in V \setminus \{r\}$ with $v \neq w$, and $T' = (V, E', r)$ be the mutation tree after the ``Swap nodes'' move from definition \ref{def:tree_moves}. We have $x \leadsto_{T'} y \Leftrightarrow f(x) \leadsto_T f(y)$ for all $x, y \in V$.
\end{lemma}

\begin{proof}
    First, it should be noted that $f$ is obviously self-inverse, so that we have $f(f(x)) = x$ and $f(f(T)) = T$. We therefore only need to show $x \leadsto_{T} y \Rightarrow f(x) \leadsto_{T'} f(y)$ since the rest follows. We have:
    \begin{align*}
        x \leadsto_T y &\Rightarrow \exists p = (x, \dots, y) = \{(x, p_2), (p_2, p_3), \dots, (p_{l-1}, y)\} \subseteq E \\
        &\Rightarrow p' = \{(f(x), f(p_2)), (f(p_2), f(p_3)), \dots, (f(p_{l-1}), f(y))\} \subseteq E' \\
        &\Rightarrow f(x) \leadsto_{T'} f(y)
    \end{align*}
\end{proof}

\begin{algorithm}[p]
    \begin{algorithmic}[1]
        \Function{AM::PruneReattach}{$V$, $a \in \{0, 1\}^{|V| \times |V|}$, $v$, $t$}
            \State $a' \leftarrow 0 \in \{0,1\}^{|V| \times |V|}$
            \ForAll{$x \in V$}
                \ForAll{$y \in V$} \Comment Unroll completely
                    \If{$a[v][y]$}
                        \State $a'[x][y] \leftarrow a[x][t] \vee (a[v][x] \wedge a[x][y])$ \Comment See lemma \ref{lem:prune_reattach_rel}
                    \Else
                        \State $a'[x][y] \leftarrow a[x][y]$ \Comment See lemma \ref{lem:prune_reattach_unrel}
                    \EndIf
                \EndFor
            \EndFor
            \State \Return $a'$
        \EndFunction
    \end{algorithmic}
    \caption{Algorithm to perform the ``prune and reattach'' move on an ancestor matrix. The node $v$ is attached to the node $t$, assuming that we have $v \not\leadsto_T t$.}
    \label{alg:am_prune_reattach}
\end{algorithm}

\begin{theorem}[Correctness of the ``Prune and Reattach'' update]
    \label{theo:prune_reattach_correctness}
    Let $T = (V, E, r)$ be a mutation tree, $v \in V \setminus \{r\}$, $t \in V$ with $v \not\leadsto_T t$ and $a \in \{0,1\}^{|V| \times |V|}$ the corresponding ancestor matrix of $T$. The ancestor matrix returned by \textsc{AM::PruneReattach}$(V, a, v, t)$ (Algorithm \ref{alg:am_prune_reattach}) is the corresponding ancestor matrix of the tree $T'$ after the ``Prune and Reattach'' move (Definition \ref{def:tree_moves}).
\end{theorem}

\begin{proof}
    This theorem follows directly from lemmata \ref{lem:prune_reattach_unrel} and \ref{lem:prune_reattach_rel}.
\end{proof}

\begin{remark}
    \label{rem:prune_reattach}
    Let $T = (V, E, r)$ be a mutation tree, $v \in V \setminus \{r\}$, $t \in V$ with $v \not\leadsto_T t$ and $T' = (V, E', r)$ the mutation tree after the ``Prune and Reattach'' move from definition \ref{def:tree_moves}. We remark that we have $v \leadsto_T y \Leftrightarrow v \leadsto_{T'} y$ for all $y \in V$ and that we have $E' \setminus E = \{(t,v)\}$ as well as $E \setminus E' = \{(p_T(v), v)\}$.
\end{remark}

The idea behind $v \leadsto_T y \Leftrightarrow v \leadsto_{T'} y$ is simply that children of $v$ still stay connected to $v$ after the move. $E' \setminus E = \{(t,v)\}$ as well as $E \setminus E' = \{(p_T(v), v)\}$ can simply be checked by writing them out.

\begin{lemma}
    \label{lem:prune_reattach_unrel}
    Let $T = (V, E, r)$ be a mutation tree, $v \in V \setminus \{r\}$, $t \in V$ with $v \not\leadsto_T t$ and $T' = (V, E', r)$ the mutation tree after the ``Prune and Reattach'' move from definition \ref{def:tree_moves}. Let also $x, y \in V$ with $v \not\leadsto_T y$. We then have:
    \begin{align*}
        x \leadsto_{T'} y \Leftrightarrow x \leadsto_T y
    \end{align*}
    The idea behind this lemma is that paths in the tree are unharmed if they do not go via the removed edge $(p_T(v), v)$.
\end{lemma}

\begin{proof}
    Let's first assume $x \leadsto_{T'} y$ and $x \not\leadsto_{T} y$ to prove $x \leadsto_{T'} y \Rightarrow x \leadsto_T y$ by contradiction. There is a path $p = (p_1, \dots, p_l) \subseteq E'$ with $p_1 = x$ and $p_l = y$. We have $p \not\subseteq E$ since we would otherwise have $x \leadsto_T y$. This means that there is an edge $e \in (p \setminus E) \subseteq (E' \setminus E)$. One can easily check that $(t, v)$ is the only edge in $E' \setminus E$. We therefore have $e = (t, v)$ and $\exists i \leq l: p_i = v$. This however means that $p' := (v, p_{i+1}, \dots, y)$ is a suffix of $p$. Since $e = (t,v) \notin p'$, we have $p' \subseteq E \Rightarrow v \leadsto_{T} y$, which contradicts our precondition of $v \not\leadsto_T y$.

    Using an analogous argumentation with the assumption of $x \not\leadsto_{T'} y$ and $x \leadsto_T y$ leads to $v \leadsto_{T'} y$. From this and remark \ref{rem:prune_reattach}, $v \leadsto_T y$ follows. This is the same contradiction as above and proves $x \leadsto_T y \Rightarrow x \leadsto_{T'} y$.
\end{proof}

\begin{lemma}
    \label{lem:prune_reattach_rel}
    Let $T = (V, E, r)$ be a mutation tree, $v \in V \setminus \{r\}$, $t \in V$ with $v \not\leadsto_T t$ and $T' = (V, E', r)$ the mutation tree after the ``Prune and Reattach'' move from definition \ref{def:tree_moves}. Let also $x, y \in V$ with $v \leadsto_T y$. We then have:
    \begin{align*}
        x \leadsto_{T'} y \Leftrightarrow (v \leadsto_T x \leadsto_T y \vee x \leadsto_T t)
    \end{align*}
    The idea of this lemma is that paths over the node $v$ exist in the new tree iff they are either entirely in the subtree below $v$ or are newly established via the edge $(t, v)$.
\end{lemma}

\begin{proof}
    We have nothing to show for $x = v$ due to remark \ref{rem:prune_reattach}. Therefore, we can assume $x \neq v$ in the following. We first show $\Leftarrow$: If we have $x \leadsto_T t$, we also have $x \leadsto_{T'} t$ with $v \not\leadsto_T t$ and lemma \ref{lem:prune_reattach_unrel}. From this and $(t, v) \in E' \Rightarrow t \leadsto_{T'} v$, it follows that we have $x \leadsto_{T'} t \leadsto_{T'} v \leadsto_{T'} y \Rightarrow x \leadsto_{T'} y$.

    We now show $\Rightarrow$: Let $p = (p_1, \dots, p_l) \subseteq E'$ be the path from $x$ to $y$ in $T'$ ($p_1 = x$ and $p_l = y$). If $(t, v) \in p$, we then have $x \leadsto_{T'} t$, and with $v \not\leadsto_T t$ and lemma \ref{lem:prune_reattach_unrel} also $x \leadsto_T t$. If we have $(t, v) \notin p$, we also have $x \not\leadsto_{T'} v$. From this, we need to conclude $v \leadsto_{T'} x \leadsto_{T'} y$ in order to avoid a contradiction with $v \leadsto_{T'} y$. Lastly, we have $v \leadsto_T x \leadsto_T y$ with remark \ref{rem:prune_reattach} and since we neither have $(v, t) \in p$ nor $(p_T(v), v) \in p$.
\end{proof}

\begin{algorithm}[p]
    \begin{algorithmic}[1]
        \Function{AM::SwapUnrelatedSubtrees}{$V$, $a \in \{0, 1\}^{|V| \times |V|}$, $v$, $w$}
        \State $a' \leftarrow 0 \in \{0,1\}^{|V| \times |V|}$
        \ForAll{$x \in V$}
            \ForAll{$y \in V$} \Comment Unroll completely
                \If{$a[v][y] \wedge \neg a[w][y]$}
                    \State $a'[x][y] \leftarrow a[x][p_T(w)] \vee (a[v][x] \wedge a[x][y])$
                \ElsIf{$\neg a[v][y] \wedge a[w][y]$}
                    \State $a'[x][y] \leftarrow a[x][p_T(v)] \vee (a[v][x] \wedge a[x][y])$
                \Else
                    \State $a'[x][y] \leftarrow a[x][y]$
                \EndIf
            \EndFor
        \EndFor
        \State \Return $a'$
        \EndFunction
    \end{algorithmic}
    \caption{Algorithm to perform the ``swab subtrees'' move for unrelated subtrees on an ancestor matrix. The node $v$ is attached to $p_T(w)$ and the node $w$ is attached to $p_T(v)$, assuming that we have $v \neq w$, $v \not\leadsto_T w$, and $w \not\leadsto_T v$.}
    \label{alg:am_swap_unrelated}
\end{algorithm}

\begin{theorem}[Correctness of the ``Swap unrelated Subtrees'' update]
    \label{theo:swap_unrelated_correctness}
    Let $T = (V, E, r)$ be a mutation tree, $v,w \in V \setminus \{r\}$, with $v \not\leadsto_T w$ and $w \not\leadsto_T v$, and $a \in \{0,1\}^{|V| \times |V|}$ the corresponding ancestor matrix of $T$. The ancestor matrix returned by \textsc{AM::SwapUnrelatedSubtrees}$(V, a, v, w)$ (Algorithm \ref{alg:am_swap_unrelated}) is the corresponding ancestor matrix of the tree $T'$ after the ``Swap unrelated subtrees'' move (Definition \ref{def:tree_moves}).
\end{theorem}

\begin{proof}
    First of all, we can remark that the ``Swap unrelated subtrees'' move is equivalent to two ``Prune and Reattach'' moves, first with parameters $v, p_T(w)$ and then with parameters $w, p_T(v)$ ($p_T(v)$ represents the parent of $v$ \textit{before} the first move). Therefore, we can prove the correctness by looking at every pair $x,y \in V$ and showing that \textsc{AM::SwapUnrelatedSubtrees} \ref{alg:am_swap_unrelated} assigns the same values as two \textsc{AM::PruneReattach} \ref{alg:am_prune_reattach} calls would. Like the algorithm, we consider the following cases:
    \begin{itemize}
        \item $v \leadsto_T y$ and $w \not\leadsto_T y$: The first call $a' \leftarrow \textsc{AM::PruneReattach}(V, a, v, p_T(w))$ assigns 
        \begin{align*}
            a'[x][y] \leftarrow a[x][p_T(w)] \vee (a[v][x] \wedge a[x][y])
        \end{align*}
        and the second call $a'' \leftarrow \textsc{AM::PruneReattach}(V, a', w, p_T(v))$ assigns $a''[x][y] \leftarrow a'[x][y]$. \textsc{AM::SwapUnrelatedSubtrees} is therefore correct in this case.
        \item $v \not\leadsto_T y$ and $w \leadsto_T y$: This case is analogous to the previous one.
        \item $v \not\leadsto_T y$ and $w \not\leadsto_T y$: Both calls to \textsc{AM::PruneReattach} forward the previous value of $a[x][y]$, just like \textsc{AM::SwapUnrelatedSubtrees} does.
        \item $v \leadsto_T y$ and $w \leadsto_T y$: This case is not possible since it would lead to either $v \leadsto_T w \leadsto_T y$ or $w \leadsto_T v \leadsto_T y$, which would contradict our assumption of $v \not\leadsto_T w$ and $w \not\leadsto_T v$. It is therefore safe for \textsc{AM::SwapUnrelatedSubtrees} to not catch this case.
    \end{itemize}
    \textsc{AM::SwapUnrelatedSubtrees} is therefore correct in all cases.
\end{proof}


\begin{algorithm}[p]
    \begin{algorithmic}[1]
        \Function{AM::SwapRelatedSubtrees}{$V$, $a \in \{0, 1\}^{|V| \times |V|}$, $v$, $w$, $t$}
        \State $a' \leftarrow 0 \in \{0,1\}^{|V| \times |V|}$
        \ForAll{$x \in V$}
            \If{$a[v][x]$}
                \State $c_x \leftarrow 2$
            \ElsIf{$a[w][x]$}
                \State $c_x \leftarrow 1$
            \Else
                \State $c_x \leftarrow 0$
            \EndIf

            \ForAll{$y \in V$} \Comment Unroll completely
                \If{$a[v][y]$}
                    \State $c_y \leftarrow 2$
                \ElsIf{$a[w][x]$}
                    \State $c_y \leftarrow 1$
                \Else
                    \State $c_y \leftarrow 0$
                \EndIf

                \If{$(c_x = c_y) \vee (c_x = 0 \wedge c_y \neq 0)$}
                    \State $a'[x][y] \leftarrow a[x][y]$
                \ElsIf{$c_x = 2 \wedge c_y = 1$}
                    \State $a'[x][y] \leftarrow a[x][t]$
                \Else
                    \State $a'[x][y] \leftarrow 0$
                \EndIf
            \EndFor
        \EndFor
        \State \Return $a'$
        \EndFunction
    \end{algorithmic}
    \caption{Algorithm to perform the ``swab subtrees'' move for related subtrees on an ancestor matrix. The node $v$ is attached to $p_T(w)$ and the node $w$ is attached to $t$, assuming that we have $v \neq w$ and $w \leadsto_T v$.}
    \label{alg:am_swap_related}
\end{algorithm}

