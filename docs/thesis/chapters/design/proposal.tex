\section{Move Proposals}
\label{sec:move_proposal}

Another area of concern in the design of \ac{ffSCITE} was the sampling of random experiments to propose state changes. On multiple occasions in the \textsc{ChainStep} algorithm (Algorithm \ref{alg:scite-step}), parameters of later actions are sampled uniformly from a set of options and a Bernoulli trial decides whether the newly proposed state is accepted as the new current state. These samples require a source of randomness, and Jahn et al. \cite{tree2016} used the \texttt{rand} function from the standard C library for their reference implementation. This function is however not available on \acp{FPGA}, so we had to use other methods. The C++ standard library provides a framework for handling random numbers that differentiates between \acp{URNG}, which sample uniformly from a set of integers fixed by their design, and distribution classes, which take the output of any \ac{URNG} to provide a sample of the requested distribution. This may be a uniform distribution from a smaller or bigger set than the original output, but it may also be a Bernoulli trial or a normal distribution. 

Deciding on a \ac{URNG} is a big decision: Different generators have different statistical properties, but may also be harder or easier to implement as a chip design. As it is common practice, we decided to initially use a simple \ac{URNG} that may or may not be perfect for our use case and to exchange it once we encountered problems either with its output quality or performance. This \ac{URNG} is \texttt{oneapi::dpl::minstd\_rand}, an implementation of the Minstd \ac{URNG} \cite{park1988random} provided by Intel in the OneDPL library. Park and Miller, the authors of Minstd, advertised it with the words ``We believe that this is the generator that should always be used- unless one has access to a random number generator known to be better.'' \cite{park1988random} Since the implementation also does not have any internal loops which could cause structural problems, this \ac{URNG} was a good first choice for us. Other, more popular \acp{URNG} like the Mersenne Twister \cite{matsumoto1998mersenne} did not meet this criterion and where therefore discarded for our initial implementation. Finding a better \acp{URNG} proved to be harder than expected since we found it hard for an outsider to identify the state of the art in the field. However, since \ac{ffSCITE} already passes our quality benchmarks with Minstd, we decided prioritize other, more pressing issues discussed in the previous sections and keep working with Minstd.

There are however problems with Minstd that we had to solve: Minstd is a Lehmer random number generator \cite{lehmer1951mathematical}. This means that given a previous output or seed $X_{k}$, its next output is defined as $X_{k+1} = a \cdot X_k \mod m$ for well-chosen parameters $a$ and $m$. In the case of Minstd, these are $a = 48271$ and $m = 2^{32} - 1 = 2147483647$. An implementation of Minstd, therefore, needs to work integers wider than 32 bits, and since \texttt{oneapi::dpl::minstd\_rand} is designed to work on \acp{CPU}, \acp{GPU} and \acp{FPGA}, it uses 64-bit integers. 64-bit modulo operations are however \emph{very} resource-intensive on \acp{FPGA} and require multiple cycles to complete. Lastly, the output of Minstd is supposed to appear random and is fed back as the new state of the generator. It is therefore impossible to predict the new state of the \ac{URNG} and any loop that draws from a \ac{URNG} has a data dependency that increases its \ac{II} significantly.

\begin{itemize}
    \item SCITE uses \texttt{rand} syscall. Not available on FPGAs, undefined characteristics.
    \item Pseodorandom framework of C++ standard library: URNG and distribution classes.
    \item Minstd0-URNG: Minimal standard as advertised by author, implemented in C++ standard library and OneDPL.
    \item Initial plan: start with minstd0, write URNG-agnostic code, research better alternative
    \item Research not possible in time, State of the art not easily identifiable by outsider
    \begin{itemize}
        \item Every URNG has drawbacks (obviously)
        \item Set of URNGs usable for MCMC very small (most research done on cryptographic URNGs)
        \item Set of URNGs usable on FPGA also very small
        \item No intersection found, little to no implementations for HLS designs.
    \end{itemize}
    \item Further research efforts appeared to be very time consuming, the quality test was already successful
    \item Decision: Work with minstd0 and leave the issue be.
    \item Minstd0 is linear congruential engine, $X_{n+1} = (a \cdot X_n) \mod m$.
    \item Problem: Implementation uses 64-bit integer. 64-bit integer is \emph{very} resource intensive. Every call to URNG creates one instance.
    \item Random draws make up XX\% of the final design, independently of input size.
    \item Next state of URNG is it's output, which is supposed to appear random: Next state unpredictable, random draws barely pipelinable.
    \item Necessary: Reduce random draws to a minimum, move them into own kernel, make kernel loop as short as possible.
\end{itemize}