\section{Background}

SCITE is supposed to be used in the following scenario: A physician has been able to extract tumor tissue from a patient, either through surgery or other methods. Then, individual cells are extracted from the tissue and their genome is sequenced. The resulting sequence of base pairs is scanned for subsequences, so-called genes. These genes may either be present in their most common form or in a less common, mutated way. The scanner identifies these mutations and produces a mutation matrix with an entry for every cell-gene-combination, where a 1 denotes that the cell has this mutation and 0 denotes the opposite.

This matrix itself may already be interesting to evaluate, but it should be handled with caution; The process of amplifying and sequencing the genome is very prone to errors. While there is often only a small chance to identify a mutation where there isn't one (false positives), there is a high change to miss a mutation (false negative). Lastly, there is also a high chance that genes are simply lost in the process. In this case, the matrix contains a third ``unknown'' entry encoded as a 2.

\todo[inline]{Research probabilites in the real world}

It is however possible to catch some of these errors with some assumptions on how mutations are introduced to the tumor: First of all, we assume that there are no mutations in the observed genes outside of the tumor. This means that before the tumor came into existence, there were only perfectly normal cells. When a cell replicates itself, it creates a perfect copy of its own genome for one of the two new cells, and these pass their genome to their subclones too. However, cells can not share or swap their genome. If a cell receives a random mutation, it will be passed down to its subclones and its subclones only. If we then also assume that every gene only mutates once in the whole history of the tumor (the so-called infinite sites assumption), we can arrange the mutations in their order of occurrence.

\todo[inline]{Describe example tree, cell attachment, assumed true mutation matrix, concept of likelihood}

Finding a maximum-likelihood tree however is not easy. If $n$ genes are considered, the number of trees is in $O(n!)$ (Prüfer Codes), which makes an exhaustive search impractical. Jahn et al. therefore designed \ac{SCITE} as a \ac{MCMC} algorithm to empirically find the maximum likelihood tree.

\todo[inline]{Find a good paper for Prüfercodes}

A Monte Carlo algorithm runs a random experiment that produces a possible solution to a problem and evaluates how well the generated solution solves the problem. This loop of generating and evaluating a solution is then repeated multiple times and the result is the best solution the algorithm has encountered. In theory, it would suffice if the experiment had a probability greater than zero to produce a good solution, but in order to improve the solution quality and to reduce the required repetitions, one would use an experiment that produces the best solutions with a higher probability than worse solutions and that can be repeated quickly. As the name implies, \ac{MCMC} algorithms are Monte Carlo algorithms that simulate a Markov Chain to produce solutions. The advantage of using Markov Chains is that the next sample may depend on the previous one and the algorithm therefore only needs to introduce small changes to the solution. This is often faster than generating a new solution from scratch and if the current sample is already a good solution, the change may preserve some of its quality. However, a designer of a \ac{MCMC} algorithm has to make sure that the chain actually converges on the desired distribution.